#![warn(missing_docs)]
//! # tlcfi_assimilator
//!
//! `tlcfi_assimilator` is a program that makes sense of tlcfi data generated by SmartTraffic logs.

use std::{
    collections::HashMap,
    fmt::Debug,
    fs::File,
    io::{BufRead, BufReader},
};

use json::JsonValue;

/// The entry point for this program
///
/// Expects a file `tlcfi.txt` with lines looking like the following:
///
/// ```
/// 2021-10-15 16:07:42,994 INFO tlcFiMessages:41 - IN - {"jsonrpc":"2.0","method":"UpdateState","params":{"ticks":2181449574,"update":[{"objects":{"ids":["01","04","05","06","12"],"type":3},"states":[{"predictions":[{"likelyEnd":2181456774,"maxEnd":2181468174,"minEnd":2181456774,"state":6},{"likelyEnd":2181460774,"maxEnd":2181472174,"minEnd":2181460774,"state":8}]},{"predictions":[{"confidence":15,"likelyEnd":2181450174,"maxEnd":2181450574,"minEnd":2181450174,"state":3},{"likelyEnd":2181456174,"maxEnd":2181535574,"minEnd":2181456174,"state":6},{"likelyEnd":2181460174,"maxEnd":2181539574,"minEnd":2181460174,"state":8}]},{"predictions":[{"confidence":3,"minEnd":2181449674,"state":3}]},{"predictions":[{"likelyEnd":2181455574,"maxEnd":2181529974,"minEnd":2181455574,"state":6},{"likelyEnd":2181459574,"maxEnd":2181533974,"minEnd":2181459574,"state":8}]},{"predictions":[{"confidence":3,"minEnd":2181449674,"state":3}]}]}]}}
/// ```
///
/// Looking from the end of the line, it is split in three parts using `-` as a delimiter.
fn main() {
    let filename = "tlcfi.txt";
    // Open the file in read-only mode (ignoring errors).
    let file = File::open(filename).unwrap();
    let reader = BufReader::new(file);

    let mut first_tick = Option::None;

    let mut signal_changes: Vec<SignalChanges> = Vec::new();

    // Read the file line by line using the lines() iterator from std::io::BufRead.
    let mut reverse_lines = Vec::new();
    for line in reader.lines() {
        reverse_lines.insert(0, line.unwrap());
    }

    for line in reverse_lines {
        let split_line: Vec<&str> = line.split("- ").collect();

        // Only consider message from the TLC.
        if split_line[1].contains("IN") {
            if first_tick == Option::None {
                first_tick = find_first_tick(&split_line[2]);
                println!("Found first tick: {:?}", &first_tick);
            }
            println!("{:?}", &line);

            let stuff = parse_string(split_line[2], first_tick.unwrap());
            signal_changes.extend(stuff.unwrap());
        }
    }

    to_vlog3(signal_changes);
}

fn find_first_tick(first_line_json: &str) -> Option<u64> {
    let json_res = json::parse(first_line_json);
    match json_res {
        Ok(json_obj) => match &json_obj["params"]["ticks"] {
            JsonValue::Number(number) => Option::Some(number.as_fixed_point_u64(0).unwrap()),
            _ => Option::None,
        },
        Err(_) => Option::None,
    }
}

fn parse_string(json_str: &str, first_tick: u64) -> Result<Vec<SignalChanges>, &str> {
    let json_res = json::parse(json_str);
    match json_res {
        Ok(json_obj) => Ok(parse_json(json_obj, first_tick)),
        Err(_) => Err("Failed to parse json string"),
    }
}

fn parse_json(json_obj: JsonValue, first_tick: u64) -> Vec<SignalChanges> {
    let signal_changes = vec![];

    let message_type = match &json_obj["params"]["update"][0]["objects"]["type"] {
        JsonValue::Number(number) => number.as_fixed_point_u64(0).unwrap(),
        _ => {
            println!("message doesn't have a type number...");
            0
        }
    };

    if message_type != 3 {
        // TODO read detector messages
        Vec::new()
    } else {
        parse_signal_change_json(json_obj, first_tick, signal_changes)
    }
}

fn parse_signal_change_json(
    json_obj: JsonValue,
    first_tick: u64,
    mut signal_changes: Vec<SignalChanges>,
) -> Vec<SignalChanges> {
    let ms_from_beginning = match &json_obj["params"]["ticks"] {
        JsonValue::Number(number) => {
            let tick = number.as_fixed_point_u64(0).unwrap();
            if tick < first_tick {
                println!(
                    "Tick in message ({:?}) wasn't bigger than initial tick!",
                    &tick
                );
                0
            } else {
                number.as_fixed_point_u64(0).unwrap() - first_tick
            }
        }
        _ => {
            //TODO handle this better
            println!(
                "Somehow ticks weren't present {:?}",
                &json_obj["params"]["ticks"]
            );
            1
        }
    };
    let update = &json_obj["params"]["update"][0];
    if update["objects"]["ids"] == JsonValue::Null {
        return vec![];
    }
    let ids_vec = match &update["objects"]["ids"] {
        JsonValue::Array(vec) => vec,
        _ => panic!("yeet"),
    };
    let states_vec = match &update["states"] {
        JsonValue::Array(vec) => vec,
        _ => panic!("yeet"),
    };

    assert_eq!(ids_vec.len(), states_vec.len(), "We assume that the amount of IDs and signal states is equal, but for the following tlc-fi json it wasn't:\n{:#}.", json_obj);

    let mut signal_names = Vec::new();
    let mut signal_states = Vec::new();
    for (i, id) in ids_vec.iter().enumerate() {
        let name: &str = match id {
            JsonValue::Short(short) => short.as_str(),
            JsonValue::String(string) => string,
            _ => panic!("yeet"),
        };

        let state_num = match &states_vec[i]["state"] {
            JsonValue::Number(number) => number.as_fixed_point_u64(0).unwrap(),
            JsonValue::Null => continue,
            _ => panic!("yeet"),
        };

        &signal_names.push(name.to_string());
        &signal_states.push(state_num.into());
    }

    if !signal_names.is_empty() {
        println!(
            "Found signal names {:?} and signal states {:?}",
            &signal_names, &signal_states
        );
        signal_changes.push(SignalChanges {
            ms_from_beginning,
            signal_names,
            signal_states,
        });
    }
    signal_changes
}

fn to_vlog3(signal_changes_vec: Vec<SignalChanges>) {
    let vlog_signal_name_mapping: HashMap<&str, i16> = [
        ("02", 0),
        ("03", 1),
        ("04", 2),
        ("06", 3),
        ("07", 4),
        ("08", 5),
        ("58", 6),
        ("59", 7),
        ("61", 8),
        ("62", 9),
        ("68", 10),
        ("69", 11),
        ("71", 12),
    ]
    .iter()
    .cloned()
    .collect();
    // types
    // 5  - STATUS_DETECTION_INFORMATION - detector status
    // 6  - CHANGE_DETECTION_INFORMATION - detector change
    // 13 - STATUS_EXTERNAL_SIGNALGROUP_STATUS_WUS - signal status
    // 14 - CHANGE_EXTERNAL_SIGNALGROUP_STATUS_WUS - signal change

    //TODO impl first messages in vlog cycle

    // The structure for a CHANGE_EXTERNAL_SIGNALGROUP_STATUS_WUS
    // description  hex digits
    // type         2
    // time delta   3
    // data amount  1
    // amount times
    //   id         2
    //   state      2

    let message_type = "0E";
    let mut last_ms_since = 0;

    for signal_changes in signal_changes_vec {
        let delta_time_ds = format!(
            "{:03X}",
            (signal_changes.ms_from_beginning - last_ms_since) / 100
        );
        last_ms_since = signal_changes.ms_from_beginning;
        let data_amount = format!("{:?}", signal_changes.signal_names.len());
        let static_string = format!("{:}{:}{:}", message_type, delta_time_ds, data_amount);
        let mut dynamic_string = String::new();
        for (i, signal_name) in signal_changes.signal_names.iter().enumerate() {
            dynamic_string.push_str(&format!(
                "{:02X}{:02X}",
                vlog_signal_name_mapping.get(signal_name as &str).unwrap(),
                signal_changes.signal_states[i].to_vlog_state()
            ));
        }
        let full_string = format!("{}{}", static_string, dynamic_string);
        println!("{}", full_string);
    }
}

#[derive(Debug)]
struct SignalChanges {
    ms_from_beginning: u64,
    signal_names: Vec<String>,
    signal_states: Vec<SignalState>,
}

#[derive(Debug)]
struct DetectorChanges {
    ms_from_beginning: u64,
    detector_names: Vec<String>,
    detector_states: Vec<DetectorState>,
}

#[derive(Debug)]
enum SignalState {
    UNAVAILABLE,
    DARK,
    RED,
    AMBER,
    GREEN,
}

impl SignalState {
    fn to_vlog_state(&self) -> i16 {
        match self {
            Self::UNAVAILABLE => 4,
            Self::DARK => 4,
            Self::RED => 0,
            Self::GREEN => 1,
            Self::AMBER => 2,
        }
    }
}

#[derive(Debug)]
enum DetectorState {
    FREE,
    OCCUPIED,
}

impl DetectorState {
    fn to_vlog_state(&self) -> i16 {
        match self {
            Self::FREE => 0,
            Self::OCCUPIED => 1,
        }
    }
}

impl From<u64> for SignalState {
    fn from(tlc_fi_state: u64) -> Self {
        match tlc_fi_state {
            0 => SignalState::UNAVAILABLE,
            1 => SignalState::DARK,
            2 | 3 => SignalState::RED,
            5 | 6 => SignalState::GREEN,
            7 | 8 => SignalState::AMBER,
            _ => panic!(
                "Don't know what SignalState to transform '{}' into.",
                tlc_fi_state
            ),
        }
    }
}

impl From<u64> for DetectorState {
    fn from(tlc_fi_state: u64) -> Self {
        match tlc_fi_state {
            0 => DetectorState::FREE,
            1 => DetectorState::OCCUPIED,
            _ => panic!(
                "Don't know what DetectorState to transform '{}' into.",
                tlc_fi_state
            ),
        }
    }
}
