#![warn(missing_docs)]
//! # tlcfi_assimilator
//!
//! `tlcfi_assimilator` is a program that makes sense of tlcfi data generated by SmartTraffic logs.

use std::{
    fmt::Debug,
    fs::File,
    io::{BufRead, BufReader},
};

use json::JsonValue;

/// The entry point for this program
///
/// Expects a file `tlcfi.txt` with lines looking like the following:
///
/// ```
/// 2021-10-15 16:07:42,994 INFO tlcFiMessages:41 - IN - {"jsonrpc":"2.0","method":"UpdateState","params":{"ticks":2181449574,"update":[{"objects":{"ids":["01","04","05","06","12"],"type":3},"states":[{"predictions":[{"likelyEnd":2181456774,"maxEnd":2181468174,"minEnd":2181456774,"state":6},{"likelyEnd":2181460774,"maxEnd":2181472174,"minEnd":2181460774,"state":8}]},{"predictions":[{"confidence":15,"likelyEnd":2181450174,"maxEnd":2181450574,"minEnd":2181450174,"state":3},{"likelyEnd":2181456174,"maxEnd":2181535574,"minEnd":2181456174,"state":6},{"likelyEnd":2181460174,"maxEnd":2181539574,"minEnd":2181460174,"state":8}]},{"predictions":[{"confidence":3,"minEnd":2181449674,"state":3}]},{"predictions":[{"likelyEnd":2181455574,"maxEnd":2181529974,"minEnd":2181455574,"state":6},{"likelyEnd":2181459574,"maxEnd":2181533974,"minEnd":2181459574,"state":8}]},{"predictions":[{"confidence":3,"minEnd":2181449674,"state":3}]}]}]}}
/// ```
///
/// Looking from the end of the line, it is split in three parts using `-` as a delimiter.
fn main() {
    let filename = "tlcfi.txt";
    // Open the file in read-only mode (ignoring errors).
    let file = File::open(filename).unwrap();
    let reader = BufReader::new(file);

    let mut first_tick = Option::None;

    let mut signal_changes: Vec<SignalChange> = Vec::new();

    // Read the file line by line using the lines() iterator from std::io::BufRead.
    let mut reverse_lines = Vec::new();
    for line in reader.lines() {
        reverse_lines.insert(0, line.unwrap());
    }

    for line in reverse_lines {
        let split_line: Vec<&str> = line.split("- ").collect();

        // Only consider message from the TLC.
        if split_line[1].contains("IN") {
            if first_tick == Option::None {
                first_tick = find_first_tick(&split_line[2]);
                println!("Found first tick: {:?}", &first_tick);
            }
            println!("{:?}", &line);

            let stuff = parse_string(split_line[2], first_tick.unwrap());
            signal_changes.extend(stuff.unwrap());
        }
    }

    println!("All signal changes:\n{:?}", &signal_changes);

    draw_phasediagram(signal_changes);
}

fn find_first_tick(first_line_json: &str) -> Option<u64> {
    let json_res = json::parse(first_line_json);
    match json_res {
        Ok(json_obj) => match &json_obj["params"]["ticks"] {
            JsonValue::Number(number) => Option::Some(number.as_fixed_point_u64(0).unwrap()),
            _ => Option::None,
        },
        Err(_) => Option::None,
    }
}

fn parse_string(json_str: &str, first_tick: u64) -> Result<Vec<SignalChange>, &str> {
    let json_res = json::parse(json_str);
    match json_res {
        Ok(json_obj) => Ok(parse_json(json_obj, first_tick)),
        Err(_) => Err("Failed to parse json string"),
    }
}

fn parse_json(json_obj: JsonValue, first_tick: u64) -> Vec<SignalChange> {
    let mut signal_changes = vec![];

    let messageType = match &json_obj["params"]["update"][0]["objects"]["type"] {
        JsonValue::Number(number) => {
            println!("Type of message is {:?}", number);
            number.as_fixed_point_u64(0).unwrap()
        }
        _ => {
            println!("message doesn't have a type number...");
            0
        }
    };

    if messageType != 3 {
        // TODO read detector messages
        Vec::new()
    } else {
        // println!("ticks! {:?}", &json_obj["params"]["ticks"]);
        parse_signal_change_json(json_obj, first_tick, signal_changes)
    }
}

fn parse_signal_change_json(json_obj: JsonValue, first_tick: u64, mut signal_changes: Vec<SignalChange>) -> Vec<SignalChange> {
    let ms_from_beginning = match &json_obj["params"]["ticks"] {
        JsonValue::Number(number) => {
            let tick = number.as_fixed_point_u64(0).unwrap();
            if tick < first_tick {
                println!(
                    "Tick in message ({:?}) wasn't bigger than initial tick!",
                    &tick
                );
                0
            } else {
                number.as_fixed_point_u64(0).unwrap() - first_tick
            }
        }
        _ => {
            //TODO handle this better
            println!(
                "Somehow ticks weren't present {:?}",
                &json_obj["params"]["ticks"]
            );
            1
        }
    };
    let update = &json_obj["params"]["update"][0];
    if update["objects"]["ids"] == JsonValue::Null {
        return vec![];
    }
    let ids_vec = match &update["objects"]["ids"] {
        JsonValue::Array(vec) => vec,
        _ => panic!("yeet"),
    };
    let states_vec = match &update["states"] {
        JsonValue::Array(vec) => vec,
        _ => panic!("yeet"),
    };
    assert_eq!(ids_vec.len(), states_vec.len(), "We assume that the amount of IDs and signal states is equal, but for the following tlc-fi json it wasn't:\n{:#}.", json_obj);
    for (i, id) in ids_vec.iter().enumerate() {
        let name: &str = match id {
            JsonValue::Short(short) => short.as_str(),
            JsonValue::String(string) => string,
            _ => panic!("yeet"),
        };

        let state_num = match &states_vec[i]["state"] {
            JsonValue::Number(number) => number.as_fixed_point_u64(0).unwrap(),
            JsonValue::Null => continue,
            _ => panic!("yeet"),
        };
        signal_changes.push(SignalChange {
            ms_from_beginning,
            signal_name: name.to_string(),
            signal_state: state_num.into(),
        });
    }
    signal_changes
}

fn draw_phasediagram(signal_changes: Vec<SignalChange>) {
    for signal_change in signal_changes {}
}

#[derive(Debug)]
struct SignalChange {
    ms_from_beginning: u64,
    signal_name: String,
    signal_state: SignalState,
}

#[derive(Debug)]
struct DetectorChange {
    ms_from_beginning: u64,
    detector_name: String,
    detector_state: DetectorState,
}


#[derive(Debug)]
enum SignalState {
    UNAVAILABLE,
    DARK,
    RED,
    AMBER,
    GREEN,
}

#[derive(Debug)]
enum DetectorState {
    FREE,
    OCCUPIED,
}

impl From<u64> for SignalState {
    fn from(tlc_fi_state: u64) -> Self {
        match tlc_fi_state {
            0 => SignalState::UNAVAILABLE,
            1 => SignalState::DARK,
            2 | 3 => SignalState::RED,
            5 | 6 => SignalState::GREEN,
            7 | 8 => SignalState::AMBER,
            _ => panic!(
                "Don't know what SignalState to transform '{}' into.",
                tlc_fi_state
            ),
        }
    }
}

impl From<u64> for DetectorState {
    fn from(tlc_fi_state: u64) -> Self {
        match tlc_fi_state {
            0 => DetectorState::FREE,
            1 => DetectorState::OCCUPIED,
            _ => panic!(
                "Don't know what DetectorState to transform '{}' into.",
                tlc_fi_state
            ),
        }
    }
}
